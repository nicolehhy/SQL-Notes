##############################
#### SQL coding practice #####
##############################

## Q1 : Find out the students choosing Course1 has greater grade than the ones who choose Course2.

Tip: Find out the students choosing Course1 or Course2 first;
     Using join with the main table with 'where' to filter the result on 'greater grade' condition;
     < We can compare the grade during the 'join' process >
```SQL
SELECT a.s_num, a.stu_name
FROM
(SELECT s_num,stu_name 
FROM Student)a

INNER JOIN
(SELECT s_num,grade 
FROM Course
WHERE course=1)b
ON a.s_num=b.s_num

INNER JOIN
(SELECT s_num,grade 
FROM Course
WHERE course=2)c
ON b.s_num=c.s_num

WHERE b.grade>c.grade
```
Tip : We need to find out cd_name having both A and B comodity;
      We use 'Join' to join them so they can be rows with same cd_name and compared with each other
      Use the 'Where' filter outside these two subqueries
```SQL
SELECT a.cd_name,a.poi,b.poi
FROM
(SELECT cd_name, poi FROM as_poi 
		where lo_country_code= 'CN' 
		and lo_city_code ='NJG'
		and cmdty='CDFG')a 
INNER JOIN (SELECT cd_name, poi FROM as_poi 
		where lo_country_code= 'CN' 
		and lo_city_code ='NJG'
		and cmdty='CDFG')b ON a.cd_name=b.cd_name
WHERE a.poi > b.poi
```

### Q2 : Find out the anchors who are level 2 but have higher socre than the ones with level 1

Tip : We just need to find out the anchors whose scores are larger than the minimum socre of level 1 anchors;
      So here we can use 'where' clause, because we can set score < specific number.
```SQL
SELECT cd_name, poi FROM as_poi 
		where lo_country_code= 'CN' 
		and lo_city_code ='NJG'
		and cmdty='CDFG'
		and poi < (select min(poi) FROM as_poi 
		where lo_country_code= 'CN' 
		and lo_city_code ='NJG'
		and cmdty='K') 
```

## Q3 : Find out the students who have average score larger than 60

Tip : Find out the student_id whose avg scores are larger than 60 first;
      Then using 'INNER JOIN' to get the student_name from S table.

```SQL
select s.s_name,s.s_no,c.avg(grade)
from S s
inner join
(select s_no,avg(grade) from C c group by s_no having avg(grade) > 60 ) ON s.s_no=c.s_no
```

## Q4 : Find out the students who failed all the courses

Tip : Find out the student_id who has at least one course with 60 or more
      Then using 'NOT IN' in that range to get the student_name from S table.

```SQL
SELECT stu_name
FROM student
WHERE stu_num NOT IN ( SELECT stu_num FROM course where grade > 60)
```

## Q5 ： Find out the sum of the quantity where operation = 'BLADE‘

Tip : Notice that there would be an aggregation function 'sum()';
      Use 'group by' at the end; 
```SQL
select operation, sum(quantity)
from inchcape.iss_raw_archive_2 
where vessel = 'ASTOMOS VENUS'
and operation = 'BLDATE'
group by operation
```

# Q6 ： Find out the students who take all same courses with student 1

Tip: Find out the courses student1 take first;
     Then find out students who take at least one course different from student1;
     select out the students whose id are different from second step;
```SQL     
SELECT stu_id FROM COURSE WHERE stu_id NOT IN
(SELECT stu_id FROM COURSE WHERE c_id NOT IN
(SELECT c_id FROM Course WHERE stu_id = 1))
GROUP BY stu_id
HAVING count(*) = 
(SELECT count(c_id) FROM COURSE
WHERE stu_id = 1) and stu_id =!1
```

## Q7 : Find out the student and their avg_grade who have failed more than tow course 

Tips : Find out the students who failed more than two courses;(using GROUP BY and AVG)
       INNER JOIN the table 
```SQL
SELECT a.stu_name, b.avg_sc FROM
(SELECT stu_id, stu_name FROM Student)a
INNER JOIN 
(
SELECT stu_id,avg(grade) as avg_sc FROM Course
WHERE grade < 60
Group by stu_id
HAVING count(c_id) >2 
)b
ON a.stu_id = b.stu_id
```
## Q8 : Find out the pass_rate...

Tips : Find out how to calcualte the pass_rate; (using AVG(0,1) to calculate this)
```SQL
SELECT c_id, c_name, MAX(grade),Min(grade),AVG(grade),
       AVG(CASE WHEN grade >= 60 THEN 1 ELSE 0 END),
       AVG(CASE WHEN grade >= 70 AND grade <= 80 THEN 1 ELSE 0 END),
       AVG(CASE WHEN grade >= 80 AND grade <= 90 THEN 1 ELSE 0 END),
       AVG(CASE WHEN grade >= 90 THEN 1 ELSE 0 END)
FROM Course
GROUP BY c_id,c_name
```

## Q9 : Find out the score rank of every course

Tips : Find out the score rank of every course;(using ROW_NUMBER() OVER(PARTITION BY course ORDER BY grade)

```SQL
SELECT created_by,cmdty, poi, 
row_number() over(partition by cmdty order by poi DESC) rank FROM as_poi
where cmdty IN ('C','R') and created_by IN ('austin_swertfager','yuwen_li','demi_alifu')
order by cmdty,poi DESC
```

## Q10 : Find out the score rank of 2 and 3 in every course

Tips : Find out the score rank of every course;(using ROW_NUMBER() OVER(PARTITION BY course ORDER BY grade)

```SQL
select stu_id,c_id, grade, row_number(partition by c_id order by grade DESC) rank
from course
where rank IN (2,3)
```

## Q11 : Find out the number of each level in every course

Tips : Find out the the number of every level;
       (using count(case when then 1 else null);
```SQL
select c_id, 
       count(case when grade < 60 then 1 else null) pass_rate,
       count(case when grade > 70 and grade <80 then 1 else null) med_rate,
       count(case when grade < 80 and grade <90 then 1 else null) good_rate,
       count(case when grade > 90 then 1 else null) exc_rate
from course
group by c_id
```

## Q12 : Find out the students who were born in 1990

```SQL
select stu_id,stu_name
from student
where year(birth) = 1990
```
```SQL
select stu_id,stu_name
from student
where birth like '%1990'
```


## Q13 : Find out the students who have more than courses with same grade

```SQL
select stu_id,c_id,grade from course c1
inner join
select stu_id, c_id, grade from course c2
on c1.stu_id=c2.stu
where c1.c_id != c2.c_id and c1.grade = c2.grade
```
https://blog.csdn.net/a379850992/article/details/55655495


## Q14 : Delte the records that has same information with original one
```SQL
DELETE * WHERE id NOT IN ( SELECT MIN(id) FROM table GROUP BY name,course,socre)
```

## Q15 : There is a table with one column " name", find the groups of two-two play 
```SQL
SELECT a.team, b.team FROM team a, team b WHERE a.team < b.team
```

## Q16 : Find out the id that has larger money than '101' in every month

```SQL
SELECT *, (SELECT month, max(money) FROM table WHERE id=101 GROUP BY month)b
FROM table a
WHERE a.month = b.month and a.money > b.max(money)
```

## Q17 copy the table

SQL: select * into b from a where 1<>1       (where1=1，拷贝表结构和数据内容)
Oracle:create table b

As

Select * from a where 1=2

[<>（不等于）(SQL Server Compact)
比较两个表达式。 当使用此运算符比较非空表达式时，如果左操作数不等于右操作数，则结果为 TRUE。 否则，结果为 FALSE。]

## Q18 : Remind of something ahead of 5 mins
```SQL
SELECT event FROM table WHERE datediff('minute',f 开始时间,getdate())>5 
```
## Q19 : 两张表，一张含有员工ID和薪水情况，另一张含有部门ID和员工ID，提取出每个部门薪水最高的员工及其薪水
【考点：两种方法。1.使用窗口函数，先将两张表连接为一张表，拉通了进行部门分组排序，这样你就可以看到每一组的第一名是谁，最后选出第一名的员工即可
               2.使用group by 与max()。将两张表连接，先提取出每个部门最高薪水的小表，然后将小表与大表内连接
```SQL
SELECT dept_no
       ,emp_no
       ,salary AS maxSalary
FROM (
        SELECT dept_no
               ,s.emp_no
               ,salary
               ,RANK() OVER (PARTITION BY dept_no
                           ORDER BY salary DESC) AS ranking
        FROM dept_emp d
        JOIN salaries s
        ON d.emp_no=s.emp_no
        WHERE d.to_date='9999-01-01'
              AND s.to_date='9999-01-01'
      )a
WHERE a.ranking=1;
```
```SQL
SELECT d.dept_no
        ,s.emp_no
        ,s.salary
FROM dept_emp d
JOIN salaries s
ON d.emp_no=s.emp_no
   AND d.to_date='9999-01-01' AND s.to_date='9999-01-01'
JOIN 
(SELECT dept_no
         ,MAX(salary) AS maxSalary
 FROM dept_emp d
 JOIN salaries s
 ON d.emp_no=s.emp_no
 WHERE d.to_date='9999-01-01' AND s.to_date='9999-01-01'
 GROUP BY dept_no)a
 ON d.dept_no=a.dept_no
    AND s.salary=a.maxSalary;
```
## Q20 : 一张含有职位和薪水情况的表，提取出每个部门平均薪水
【考点：group by avg()之后的结果，可以在order BY里直接用】
```sql
SELECT t.title
       ,avg(salary) as avg_salary
FROM titles t
JOIN salaries s
ON t.emp_no=s.emp_no 
   AND t.to_date='9999-01-01'
   AND s.to_date='9999-01-01'
GROUP BY title
ORDER BY avg_salary;
```
